{-# LANGUAGE FlexibleContexts          #-}

-- |
-- Module      : Streamly.Internal.Data.Fold.KeyValue
-- Copyright   : (c) 2019 Composewell Technologies
-- License     : BSD3
-- Maintainer  : streamly@composewell.com
-- Stability   : experimental
-- Portability : GHC

module Streamly.Internal.Data.Fold.KeyValue
    (
      addFoldLocked
    , removeFoldLocked
    , runFoldRefStep
    , emptyKVFold
    )
where

import Control.Concurrent (MVar, takeMVar, putMVar)
import Control.Monad.IO.Class (MonadIO(..))
import Data.IORef (IORef, newIORef, readIORef, writeIORef)

import Streamly.Internal.Data.Fold.Types (Fold(..), runStep, finish)
import Streamly.Internal.Data.KeyValue (IsKeyValue(..))
import Streamly.Internal.Data.SVar (MonadAsync)

------------------------------------------------------------------------------
-- Compose a key value container fold dynamically
------------------------------------------------------------------------------

-- | Create a new key value fold. A key value fold is a dynamically composable
-- key value map containing constituent folds corresponding to keys. The folds
-- are stored in an IORef so that the fold is mutable, that allows us to do
-- in-place updates of the fold when we run a fold step. This helps contain the
-- garbage generated by the updates.
--
{-# INLINE emptyKVFold #-}
emptyKVFold :: (MonadAsync m, IsKeyValue kv) => Fold m a (kv k (IORef v))
emptyKVFold = Fold (\b _ -> return b) (return kvEmpty) return

-- | Distribute an input element to mutable folds (IORefs) inside a 'Foldable'
-- container. The IORef is mutated to contain folds with updated accumulator
-- state.
{-# INLINE distributeInFoldable #-}
distributeInFoldable
    :: (Foldable f, MonadIO m)
    => f (IORef (Fold m a b)) -> a -> m (f (IORef (Fold m a b)))
distributeInFoldable ss a  = do
    Prelude.mapM_ (\ref -> do
        fld <- liftIO $ readIORef ref
        -- XXX in-place modification of just the accumulator would be more
        -- efficient here, otherwise we may be generating too much garbage.
        --
        -- Having the accumulator unboxed/Storable/Prim may be more efficient
        -- to mutate/store it.
        --
        fld' <- runStep fld a
        liftIO $ writeIORef ref fld') ss
    return ss

-- | Insert a new key-value pair into a key-value container.
--
{-# INLINE insertIntoContainer #-}
insertIntoContainer
    :: (MonadAsync m, IsKeyValue kv, Traversable (kv k))
    => (k, Fold m a b)
    -> Fold m a (kv k (IORef (Fold m a b)))
    -> m (Fold m a (kv k (IORef (Fold m a b))))
insertIntoContainer (k, v) fld = do
    fs <- finish fld
    ref <- liftIO $ newIORef v
    return $ Fold distributeInFoldable (return $ kvInsert (k, ref) fs) return

-- | Delete a key from a key-value container.
--
{-# INLINE deleteFromContainer #-}
deleteFromContainer
    :: (MonadAsync m, IsKeyValue kv, Traversable (kv k), Eq k)
    => k
    -> Fold m a (kv k (IORef (Fold m a b)))
    -> m (Fold m a (kv k (IORef (Fold m a b))))
deleteFromContainer k fld = do
    fs <- finish fld
    return $ Fold distributeInFoldable (return (kvDelete k fs)) return

------------------------------------------------------------------------------
-- Atomically update the KV fold using an MVar
------------------------------------------------------------------------------

modifyIORefWithLock
    :: MonadIO m => MVar () -> IORef a -> (a -> m a) -> m ()
modifyIORefWithLock mvar ref action = do
    liftIO $ takeMVar mvar
    r <- liftIO $ readIORef ref
    -- XXX handle when the socket exists in the list
    newF <- action r
    liftIO $ do
        writeIORef ref newF
        putMVar mvar ()

-- XXX handle exception
{-# INLINE runFoldRefStep #-}
runFoldRefStep :: MonadIO m
    => IORef (Fold m a (kv k (IORef (Fold m a b)))) -> a -> m ()
runFoldRefStep ref x = do
    fld <- liftIO $ readIORef ref
    -- We can safely discard the return value as the container fold keeps
    -- state in the IORef which gets mutated by the step.
    _ <- runStep fld x
    return ()

-- XXX handle when the socket exists in the list
addFoldLocked
    :: (MonadAsync m, IsKeyValue kv, Traversable (kv k))
    => MVar ()
    -> IORef (Fold m a (kv k (IORef (Fold m a b))))
    -> (k, Fold m a b)
    -> m ()
addFoldLocked mvar ref kv =
    modifyIORefWithLock mvar ref (insertIntoContainer kv)

-- XXX handle when socket is not in the list
removeFoldLocked
    :: (MonadAsync m, IsKeyValue kv, Traversable (kv k), Eq k)
    => MVar ()
    -> IORef (Fold m a (kv k (IORef (Fold m a b))))
    -> k
    -> m ()
removeFoldLocked mvar ref k =
    modifyIORefWithLock mvar ref (deleteFromContainer k)
